/*
How the algorithm work

1. use hill climbing to find the shortest path to visit all node
2. when there is no gallon left use heuristik A* to find the shortest path to one of water depot
3. use the heuristic path that created from (number 2) to go back to last client node that you visisted
    (reverse heuristic path)
4. when the current position are in the last client node, continue the travel using the path that has been
    generated by (number 1)

*/


const graph = {
    'C1' : [{'node':'D1', 'cost':3},{'node':'D2', 'cost':15},{'node':'C4', 'cost':9}],
    'C2' : [{'node':'D1', 'cost':8},{'node':'D2', 'cost':4},{'node':'C3', 'cost':6}],
    'C3' : [{'node':'C2', 'cost':6},{'node':'C6', 'cost':2},{'node':'C7', 'cost':14}],
    'C4' : [{'node':'C1', 'cost':9},{'node':'C9', 'cost':11}],
    'C5' : [{'node':'D2', 'cost':11},{'node':'C10', 'cost':2},{'node':'C8', 'cost':7}],
    'C6' : [{'node':'C3', 'cost':2},{'node':'C8', 'cost':5}],
    'C7' : [{'node':'C3', 'cost':14},{'node':'D3', 'cost':20}],
    'C8' : [{'node':'D3', 'cost':13},{'node':'C6', 'cost':5},{'node':'C5', 'cost':7},{'node':'C10', 'cost':3}],
    'C9' : [{'node':'C4', 'cost':11},{'node':'D4', 'cost':8}],
    'C10': [{'node':'C8', 'cost':3},{'node':'C5', 'cost':2},{'node':'D4', 'cost':16}],
    'D1': [{'node':'C1', 'cost':3},{'node':'C2', 'cost':8}],
    'D2': [{'node':'C1', 'cost':15},{'node':'C2', 'cost':4},{'node':'C5', 'cost':11}],
    'D3': [{'node':'C7', 'cost':20},{'node':'C8', 'cost':13}],
    'D4': [{'node':'C10', 'cost':16},{'node':'C9', 'cost':8}],
};

const nodesCoordinates = {
    'C1' : [24, 6],
    'C2' : [14, 9],
    'C3' : [ 9, 7],
    'C4' : [20, 3],
    'C5' : [14, 3],
    'C6' : [ 8, 4],
    'C7' : [ 2, 5],
    'C8' : [ 9, 1],
    'C9' : [27, 3],
    'C10': [16, 0],
    'D1' : [21, 8],
    'D2' : [16, 6],
    'D3' : [ 2, 2],
    'D4' : [23, 1],
}

const depoNode = ['D1','D2','D3','D4']

const clientOrder = {
    'C1' : [10, true],
    'C2' : [14, true],
    'C3' : [20, true],
    'C4' : [15, true],
    'C5' : [25, true],
    'C6' : [21, true],
    'C7' : [22, true],
    'C8' : [23, true],
    'C9' : [33, true],
    'C10': [18, true],
}

let combination = ['D1','C1','C4','C9','D4','C10','C5','D2','C2','C3','C7','D3','C8','C6']
let total_cost = 0
let astar_cost = 0
let depo = 50
let blocked_idx = [0,0]
let available =  false
let astarpath = []
let comparison = []
let blockedNodes = []



const pathChecker = function(path){
    available = false
    total_cost = 0
    for (let i = 1; i < path.length; i++){
        for(j in graph){
            if(path[i-1] == j){
                //console.info("Node : "+j)
                for(node of graph[j]){
                    if(node['node'] == path[i]){
                        //console.log("Connected Node : "+node['node'])
                        //console.log("Node Cost : "+node['cost'])
                        total_cost += node['cost']
                        available = true
                        break
                    }
                    else{
                        //console.info("Node Offline")
                    }
                }
                if(!available){
                    return false
                }
            }
        }
    }
    return true
}

//console.info(graph.slice(10,13))

const hillClimbing  = function(path){
    console.info("Path : "+ pathChecker(path))
    console.info("Total cost = "+total_cost)

}

/*

--------------------------A* Algorithm component--------------------------

*/

const neighboarsCheck = function(currentNode){
    comparison = []
    for(nodes of graph[currentNode]){
        if( !(comparison.length) && depoNode.includes(nodes['node']) ){
            comparison.push(nodes['node'])
            comparison.push(nodes['cost'])
        } else if( depoNode.includes(nodes['node']) && nodes['cost'] < comparison[1]){
            comparison[0] = nodes['node']
            comparison[1] = nodes['cost']
        }
    }
    if(comparison[1] != null){
        astar_cost += comparison[1]
    }
    return comparison[0]
}

function euclideanDistance(currentNode_x, currentNode_y, goalNode_x, goalNode_y) {
  return Math.sqrt(Math.pow(currentNode_x - goalNode_x, 2) + Math.pow(currentNode_y - goalNode_y, 2));
}

function astarEquation(gn,currentNode, goalNode){
    return gn + euclideanDistance( nodesCoordinates[currentNode][0], nodesCoordinates[goalNode][0], nodesCoordinates[currentNode][1], nodesCoordinates[goalNode][1] )
}

const astar = function(currentNode){
    astarpath    = []
    blockedNodes = []
    astar_cost = 0
    while(true){
        astarpath.push(currentNode)
        blockedNodes.push(currentNode)
        let ncResult = neighboarsCheck(currentNode)
        if(ncResult != null){
            astarpath.push(ncResult)
            //console.log(astarpath)
            break
        }
        //console.log("bloacked Nodes = "+blockedNodes)
        if(!(depoNode.includes(astarpath[astarpath.length-1])) ){
            comparison = []
            for(nodes of graph[currentNode]){
                if( !(blockedNodes.includes(nodes['node'])) ){
                    if( !(comparison.length) ){
                        comparison.push(nodes['node'])
                        comparison.push( astarEquation(nodes['cost'], currentNode, nodes['node']) )

                    }else if( astarEquation(nodes['cost'], currentNode, nodes['node']) < comparison[1]){
                        //console.log("Optimal Node = "+nodes['node'])
                        comparison[0]  = nodes['node']
                        comparison[1] = astarEquation(nodes['cost'], currentNode, nodes['node'])
                    }
                }
            }
            //console.log(typeof comparison[1] + " + " + typeof total_cost);
            astar_cost += comparison[1]
            //console.info( total_cost+" + "+comparison[1]+" = "+total_cost)
            currentNode = comparison[0]
            //console.log(astarpath)
        }
    }
    let temp = astarpath.slice(0,astarpath.length-1)
    console.log("\n total A* cost = "+ astar_cost*2)
    return astarpath.concat(temp.reverse())
}


/*

--------------------------Main Function--------------------------

*/

const main = function(){
    pathChecker(combination)
    let temp
    for( currentNode of combination){
        if(clientOrder.hasOwnProperty(currentNode) && clientOrder[currentNode][0] <= depo){
            depo -= clientOrder[currentNode][0]
            clientOrder[currentNode] = 0
            console.info("Galon telah dikirim ke node -> "+currentNode)
        }else if(clientOrder.hasOwnProperty(currentNode) && clientOrder[currentNode][0] > depo){
            console.log("kekuarangan galon untuk node -> "+currentNode)
            temp = astar(currentNode)
            console.table(temp)
            for(cNode of temp){
                if(depoNode.includes(cNode)){
                    depo = 50
                }else{
                    console.log("Numpang lewat node "+cNode)
                }
            }
            console.log("depo telah penuh")
            depo -= clientOrder[currentNode][0]
            clientOrder[currentNode] = 0
            console.info("Galon telah dikirim ke node -> "+currentNode)
        }
        console.log("sisa depo = "+depo)
    }
    total_cost += astar_cost
    console.table(clientOrder)
    console.log("Total Cost = "+total_cost)
}
main()
